{
  // Place your cpp_work ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
  // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
  // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
  // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
  // Placeholders with the same ids are connected.
  // Example:
  // "Print to console": {
  // 	"scope": "javascript,typescript",
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }
  "main function for kyopro": {
    "prefix": "main",
    "body": [
      "#include <iostream>",
      "#include <vector>",
      "#include <string>",
      "#include <algorithm>",
      "#include <tuple>",
      "",
      "int main() {",
      "  std::cout << \"Hello, World!\" << std::endl;",
      "",
      "  return 0;",
      "}"
    ],
    "description": "Basic main function for programing contest"
  },
  "UnionFind": {
    "prefix": "UnionFind",
    "body": [
      "/**",
      " * Class implementation of Disjoint-Set Union tree(a.k.a Union-Find Tree).",
      " */",
      "class UnionFind {",
      " private:",
      "  // A vector retaining the parent node of the node.",
      "  std::vector<int64_t> parent;",
      "  // A vector retaining the rank of the node.",
      "  std::vector<int64_t> rank;",
      "  // A vector retaining the size of the subtree to which belonging the node.",
      "  std::vector<int64_t> size;",
      "",
      " public:",
      "  /**",
      "   * Constructor",
      "   *",
      "   * @param n Number of nodes.",
      "   *",
      "   */",
      "  UnionFind(int64_t n) : parent(n, -1), rank(n, 0), size(n, 1) {",
      "    for (int64_t i = 0; i < n; i++) {",
      "      parent.at(i) = i;",
      "    }",
      "  }",
      "",
      "  /**",
      "   *",
      "   * @brief Return the root.",
      "   *",
      "   * Returns the root of the subtree to which the node x is belonging.",
      "   * In addition, route-compression is also performed.",
      "   *",
      "   * @param x The index of the specified node.",
      "   * @returns The index of the root.",
      "   *",
      "   */",
      "  int64_t root(int64_t x) {",
      "    // Return itself if node v is the root.",
      "    if (parent.at(x) == x) {",
      "      return x;",
      "    }",
      "",
      "    int64_t r = root(parent.at(x));",
      "    parent.at(x) = r;",
      "    return r;",
      "  }",
      "",
      "  /**",
      "   *",
      "   * @brief Determine if they are in same group.",
      "   *",
      "   * Determine if they are in same group.",
      "   *",
      "   * @param x The index of the node.",
      "   * @param y The index of the other node.",
      "   *",
      "   * @return True if x and y are belonging same group. Otherwise, False.",
      "   *",
      "   */",
      "  bool is_same(int64_t x, int64_t y) { return root(x) == root(y); }",
      "",
      "  /**",
      "   * @brief Merge specified two nodes.",
      "   *",
      "   * @param x The index of the node.",
      "   * @param y The index of the other node.",
      "   *",
      "   * @return False if x and y are already in same group.",
      "   */",
      "  bool unite(int64_t x, int64_t y) {",
      "    // Move to each root.",
      "    x = root(x);",
      "    y = root(y);",
      "",
      "    // Return false if x and y are already in same group.",
      "    if (x == y) {",
      "      return false;",
      "    }",
      "",
      "    // Swap so that the rank of x is higher.",
      "    if (rank.at(x) < rank.at(y)) {",
      "      std::swap(x, y);",
      "    }",
      "",
      "    // If the two trees are the same rank, the rank increases by 1 after merge.",
      "    if (rank.at(x) == rank.at(y)) {",
      "      ++rank.at(x);",
      "    }",
      "",
      "    // Update parent.",
      "    parent.at(y) = x;",
      "",
      "    // Update size.",
      "    size.at(x) += size.at(y);",
      "",
      "    // Successfully merged.",
      "    return true;",
      "  }",
      "",
      "  // Size of the group to which x belongs",
      "  /**",
      "   * @brief Returns the size of the subtree.",
      "   *",
      "   * @param x The index of the node.",
      "   *",
      "   * @return The size of the subtree.",
      "   */",
      "  int64_t get_size(int64_t x) { return size.at(root(x)); }",
      "};"
    ],
    "description": "UnionFind"
  },
  "Coordinate Compress": {
    "prefix": "coordinate_compress",
    "body": [
      "template <class T> std::vector<T> coordinate_compress(std::vector<T> input) {",
      "  std::vector<T> output(input.size());",
      "",
      "  std::vector<T> copy = input;",
      "  std::sort(copy.begin(), copy.end());",
      "",
      "  copy.erase(std::unique(copy.begin(), copy.end()), copy.end());",
      "  for (size_t i = 0; i < input.size(); i++) {",
      "    output.at(i) = std::distance(copy.begin(),std::lower_bound(copy.begin(), copy.end(), input.at(i)));",
      "  }",
      "",
      "  return output;",
      "}"
    ],
    "description": "A function that performs coordinate compress on std::vector"
  },
  "Euclidean Algorithm": {
    "prefix": "euclidean_algorithm",
    "body": [
      "int64_t gcd(int64_t x, int64_t y) {",
      "  if (x < 0 || y < 0) return -1;",
      "",
      "  if (y == 0) return x;",
      "  else return gcd(y, x % y);",
      "}"
    ],
    "description": "Implementation of the Euclidean Algorithm"
  },
  "Eratosthenes Sieve": {
    "prefix": "eratosthenes_sieve",
    "body": [
      "class EratosthenesSieve {",
      " public:",
      "  int64_t Number_;",
      "  std::vector<bool> is_prime_;",
      "  std::vector<int64_t> primes_;",
      "  std::vector<int64_t> minimum_factor_;",
      "",
      "  EratosthenesSieve(int64_t N)",
      "      : Number_(N),",
      "        is_prime_(N + 1, true),",
      "        primes_(0),",
      "        minimum_factor_(N + 1, -1) {",
      "    is_prime_.at(1) = false;",
      "    minimum_factor_.at(1) = 1;",
      "",
      "    for (int64_t p = 2; p <= N; p++) {",
      "      if (!is_prime_.at(p)) continue;",
      "",
      "      primes_.push_back(p);",
      "      minimum_factor_.at(p) = p;",
      "",
      "      for (int64_t q = p * 2; q <= N; q += p) {",
      "        is_prime_.at(q) = false;",
      "",
      "        if (minimum_factor_.at(q) == -1) {",
      "          minimum_factor_.at(q) = p;",
      "        }",
      "      }",
      "    }",
      "  }",
      "",
      "  std::vector<std::pair<int64_t, int64_t>> factorize(int64_t N) {",
      "    if (N > Number_) return {};",
      "    std::vector<std::pair<int64_t, int64_t>> result;",
      "    while (N > 1) {",
      "      int64_t p = minimum_factor_.at(N);",
      "      int64_t exp = 0;",
      "",
      "      while (minimum_factor_.at(N) == p) {",
      "        N /= p;",
      "        exp++;",
      "      }",
      "      result.push_back(std::make_pair(p, exp));",
      "    }",
      "",
      "    return result;",
      "  }",
      "",
      "  std::vector<int64_t> dividers(int64_t N) {",
      "    if (N > Number_) return {};",
      "    std::vector<int64_t> result = {1};",
      "",
      "    auto primes = factorize(N);",
      "",
      "    for (auto p : primes) {",
      "      int64_t size = static_cast<int64_t>(result.size());",
      "      for (int64_t i = 0; i < size; i++) {",
      "        int64_t v = 1;",
      "        for (int64_t j = 0; j < p.second; j++) {",
      "          v *= p.first;",
      "          result.push_back(result.at(i) * v);",
      "        }",
      "      }",
      "    }",
      "",
      "    std::sort(result.begin(), result.end());",
      "    return result;",
      "  }",
      "",
      "  std::vector<int64_t> primes(void) { return primes_; }",
      "",
      "  std::vector<bool> is_prime(void) { return is_prime_; }",
      "};"
    ],
    "description": "Implementation of Eratosthenese Sieve and its fast prime factorization and dividers enumeration"
  },
  "Iterative Power": {
    "prefix": "iterative_power",
    "body": [
      "int64_t iterative_power(int64_t a, int64_t n, int64_t p) {",
      "  if (n == 0) return 1;",
      "  if (n == 1) return a % p;",
      "  if (n % 2 == 1) return (a * iterative_power(a, n - 1, p)) % p;",
      "",
      "  int64_t t = iterative_power(a, n / 2, p);",
      "  return (t * t) %p;",
      "}"
    ],
    "description": "Implementation of Iterative Power"
  },
  "Choose Minimum": {
    "prefix": "choose_minimum",
    "body": [
      "template<class T> bool choose_minimum(T& a, T b) {",
      "  if (a > b) {",
      "    a = b;",
      "    return true;",
      "  } else {",
      "    return false;",
      "  }",
      "}"
    ],
    "description": "Implementation of choose_minimum function"
  },
  "Enumerate Dividers": {
    "prefix": "enumereate_dividers",
    "body": [
      "std::vector<int64_t> enumerate_dividers(int64_t N) {",
      "  std::vector<int64_t> dividers;",
      "",
      "  for (int64_t i = 1; i * i <= N; i++) {",
      "    if (N % i == 0) {",
      "      dividers.push_back(i);",
      "",
      "      if (N / i != i) {",
      "        dividers.push_back(N / i);",
      "      }",
      "    }",
      "  }",
      "",
      "  std::sort(dividers.begin(), dividers.end());",
      "  return dividers;",
      "}"
    ],
    "description": "Enumerate N's dividers"
  },
  "Prime Factorization": {
    "prefix": "prime_factorize",
    "body": [
      "std::vector<std::pair<int64_t, int64_t>> prime_factorize(int64_t N) {",
      "  std::vector<std::pair<int64_t, int64_t>> primes;",

      "  for (int64_t i = 2; i * i <= N; i++) {",
      "    if (N % i == 0) {",
      "      int64_t ex = 0;",

      "      while (N % i == 0) {",
      "        ex++;",
      "        N /= i;",
      "      }",

      "      primes.push_back({i, ex});",
      "    }",
      "  }",

      "  if (N != 1) {",
      "    primes.push_back({N, 1});",
      "  }",

      "  return primes;",
      "}"
    ],
    "description": "Implementation of prime factorization"
  },
  "input N": {
    "prefix": "inputN",
    "body": ["int64_t N;", "std::cin >> N;"],
    "description": "input N"
  },
  "input N and M": {
    "prefix": "inputNM",
    "body": ["int64_t N, M;", "std::cin >> N >> M;"],
    "description": "input N and M"
  },
  "input 1D vector": {
    "prefix": "inputVector1D",
    "body": [
      "std::vector<int64_t> A(N);",
      "for (int64_t i = 0; i < N; i++) {",
      "  std::cin >> A.at(i);",
      "}",
      ""
    ],
    "description": "input 1D vector"
  },
  "input 2D vector": {
    "prefix": "inputVector2D",
    "body": [
      "std::vector<std::vector<int64_t>> A(N, std::vector<int64_t>(M));",
      "for (int64_t i = 0; i < N; i++) {",
      "  for (int64_t j = 0; j < M; j++) {",
      "    std::cin >> A.at(i).at(j);",
      "  }",
      "}",
      ""
    ],
    "description": "input 2D vector"
  },
  "output answer": {
    "prefix": "outputAnswer",
    "body": ["std::cout << answer << std::endl;"],
    "description": "output answer"
  },
  "Output Yes": {
    "prefix": "outputYes",
    "body": ["std::cout << \"Yes\" << std::endl;"],
    "description": "Output Yes"
  },
  "Output No": {
    "prefix": "outputNo",
    "body": ["std::cout << \"No\" << std::endl;"],
    "description": "Output No"
  },
  "OK condition": {
    "prefix": "condition",
    "body": [
      "if (ok) {",
      "  std::cout << \"Yes\" << std::endl;",
      "} else {",
      "  std::cout << \"No\" << std::endl;",
      "}"
    ],
    "description": "Output Yes or No according to ok variable"
  },
  "ModInt": {
    "prefix": "ModInt",
    "body": [
      "#include <cassert>",
      "",
      "template <int64_t mod>",
      "class ModInt {",
      " public:",
      "  // Default constructor",
      "  ModInt() : value_(0) {}",
      "",
      "  // Converting constructor",
      "  ModInt(int64_t n) {",
      "    // Error when n is a multiple of mod",
      "    assert(n == 0 || n % mod != 0);",
      "",
      "    int64_t x = n % mod;",
      "    if (x < 0) x += mod;",
      "    value_ = x;",
      "  }",
      "",
      "  int64_t value() const { return value_; }",
      "",
      "  // Return the N-th power of the value.",
      "  ModInt power(int64_t n) const {",
      "    assert(n >= 0);",
      "",
      "    ModInt x = *this;",
      "    ModInt r = 1;",
      "",
      "    while (n) {",
      "      if (n & 1) r *= x;",
      "      x *= x;",
      "      n >>= 1;",
      "    }",
      "",
      "    return r;",
      "  }",
      "",
      "  // Return the inverse of the value.",
      "  ModInt inverse() const { return this->power(mod - 2); }",
      "",
      "  // Overload prefix increment operator",
      "  ModInt& operator++() {",
      "    value_++;",
      "    if (value_ == mod) value_ = 0;",
      "",
      "    return *this;",
      "  }",
      "",
      "  // Overload prefix decrement operator",
      "  ModInt& operator--() {",
      "    if (value_ == 0) value_ = mod;",
      "    value_--;",
      "    return *this;",
      "  }",
      "",
      "  // Overload postfix increment operator",
      "  ModInt operator++(int) {",
      "    ModInt result = *this;",
      "    ++*this;",
      "    return result;",
      "  }",
      "",
      "  // Overload postfix decrement operator",
      "  ModInt operator--(int) {",
      "    ModInt result = *this;",
      "    --*this;",
      "    return result;",
      "  }",
      "",
      "  // Overload assignment operator `+=`",
      "  ModInt& operator+=(const ModInt& rhs) {",
      "    value_ += rhs.value_;",
      "    if (value_ >= mod) value_ -= mod;",
      "    return *this;",
      "  }",
      "",
      "  // Overload assignment operator `-=`",
      "  ModInt& operator-=(const ModInt& rhs) {",
      "    if (value_ < rhs.value_) value_ += mod;",
      "    value_ -= rhs.value_;",
      "    return *this;",
      "  }",
      "",
      "  // Overload assignment operator `*=`",
      "  ModInt& operator*=(const ModInt& rhs) {",
      "    value_ = value_ * rhs.value_ % mod;",
      "    return *this;",
      "  }",
      "",
      "  // Overload assignment operator `/=`",
      "  ModInt& operator/=(const ModInt& rhs) {",
      "    return *this = *this * rhs.inverse();",
      "  }",
      "",
      "  // Overload plus operator",
      "  ModInt operator+() const { return *this; }",
      "",
      "  // Overload minus operator",
      "  ModInt operator-() const { return ModInt() - *this; }",
      "",
      "  // Overload addition operator",
      "  friend ModInt operator+(const ModInt& lhs, const ModInt& rhs) {",
      "    return ModInt(lhs) += rhs;",
      "  }",
      "",
      "  // Overload subtraction operator",
      "  friend ModInt operator-(const ModInt& lhs, const ModInt& rhs) {",
      "    return ModInt(lhs) -= rhs;",
      "  }",
      "",
      "  // Overload multiplication operator",
      "  friend ModInt operator*(const ModInt& lhs, const ModInt& rhs) {",
      "    return ModInt(lhs) *= rhs;",
      "  }",
      "",
      "  // Overload division operator",
      "  friend ModInt operator/(const ModInt& lhs, const ModInt& rhs) {",
      "    return ModInt(lhs) /= rhs;",
      "  }",
      "",
      "  // Overload equal operator",
      "  friend bool operator==(const ModInt& lhs, const ModInt& rhs) {",
      "    return lhs.value_ == rhs.value_;",
      "  }",
      "",
      "  // Overload not-equal operator",
      "  friend bool operator!=(const ModInt& lhs, const ModInt& rhs) {",
      "    return lhs.value_ != rhs.value_;",
      "  }",
      "",
      "  // Overload comparison operator `<`",
      "  friend bool operator<(const ModInt& lhs, const ModInt& rhs) {",
      "    return lhs.value_ < rhs.value_;",
      "  }",
      "",
      "  // Overload comparison operator `<`",
      "  friend bool operator>(const ModInt& lhs, const ModInt& rhs) {",
      "    return lhs.value_ > rhs.value_;",
      "  }",
      "",
      "  // Overload comparison operator `<`",
      "  friend bool operator<=(const ModInt& lhs, const ModInt& rhs) {",
      "    return lhs.value_ <= rhs.value_;",
      "  }",
      "",
      "  // Overload comparison operator `<`",
      "  friend bool operator>=(const ModInt& lhs, const ModInt& rhs) {",
      "    return lhs.value_ >= rhs.value_;",
      "  }",
      "",
      "  // Overload stream operator",
      "  friend std::ostream& operator<<(std::ostream& os, const ModInt<mod>& x) {",
      "    return os << x.value_;",
      "  }",
      "",
      " private:",
      "  int64_t value_;",
      "};"
    ],
    "description": "ModInt"
  },
  "BinominalCoefficient": {
    "prefix": "BinominalCoefficient",
    "body": [
      "// Class implementation of binominal coefficient",
      "class BinominalCoefficient {",
      " public:",
      "  BinominalCoefficient(int64_t N, int64_t mod)",
      "      : N_(N),",
      "        mod_(mod),",
      "        factorial_(N + 1, 1),",
      "        inverse_element_(N + 1, 1),",
      "        inverse_factorial_(N + 1, 1) {",
      "    for (int64_t i = 2; i <= N; i++) {",
      "      factorial_.at(i) = factorial_.at(i - 1) * i % mod_;",
      "      inverse_element_.at(i) =",
      "          mod_ - inverse_element_.at(mod_ % i) * (mod_ / i) % mod_;",
      "      inverse_factorial_.at(i) =",
      "          inverse_factorial_.at(i - 1) * inverse_element_.at(i) % mod_;",
      "    }",
      "  }",
      "",
      "  int64_t nCr(int64_t n, int64_t r) {",
      "    if (n > N_) return 0;",
      "    if (n < r) return 0;",
      "    if (n < 0 || r < 0) return 0;",
      "",
      "    return factorial_.at(n) *",
      "           (inverse_factorial_.at(r) * inverse_factorial_.at(n - r) % mod_) %",
      "           mod_;",
      "  }",
      "",
      " private:",
      "  int64_t N_;",
      "  int64_t mod_;",
      "  // Memo vector of factorial",
      "  std::vector<int64_t> factorial_;",
      "  // Memo vector of inverse element",
      "  std::vector<int64_t> inverse_element_;",
      "  // Memo vector of inverse element of factorial",
      "  std::vector<int64_t> inverse_factorial_;",
      "};"
    ],
    "description": "BinominalCoefficient"
  },
  "SegmentTree": {
    "prefix": "SegmentTree",
    "body": [
      "/**",
      " * @brief Non-recursive, and abstracted segment tree implementation.",
      " *",
      " * @tparam S Type of the element of segment tree. The pair (S, op, e) is a",
      " * monoid.",
      " * @tparam op(S, S) A function representing the binary operator.",
      " * @tparam e() A function which returns identity element.",
      " *",
      " */",
      "template <class S, S op(S, S), S e()>",
      "class SegmentTree {",
      " private:",
      "  // Number of the elements managed by segment tree.",
      "  int64_t N;",
      "  // The logarithm of size of the segment tree base 2.",
      "  int64_t log;",
      "  // Size of the vector that representing binary tree object.",
      "  int64_t size;",
      "  // A vector of the entities representing segment tree (1-indexed).",
      "  std::vector<S> data;",
      "",
      "  /**",
      "   * @brief Calculate smallest power of 2 over n.",
      "   *",
      "   * @param n",
      "   * @return Exponent of the smallest power of 2 over n.",
      "   */",
      "  int64_t get_log(int64_t n) {",
      "    int64_t x = 0;",
      "    while ((1 << x) < n) {",
      "      ++x;",
      "    }",
      "",
      "    return x;",
      "  }",
      "  /**",
      "   * @brief Update value of the element with the value of the child node.",
      "   *",
      "   * @param k The index of the node(0-indexed).",
      "   */",
      "  void update(int64_t k) {",
      "    // Apply the binary operator to each child and substitute the result.",
      "    data.at(k) = op(data.at(2 * k), data.at(2 * k + 1));",
      "  }",
      "",
      " public:",
      "  /**",
      "   * @brief Construct a new Segment Tree object",
      "   *",
      "   * @param A The initial values.",
      "   */",
      "  explicit SegmentTree(std::vector<S> A)",
      "      : N(static_cast<int64_t>(A.size())),",
      "        log(get_log(N)),",
      "        size(1 << log),",
      "        data(2 * size, e()) {",
      "    // Initialize leaves with given vector.",
      "    for (int64_t i = 0; i < N; i++) {",
      "      data.at(i + size) = A.at(i);",
      "    }",
      "",
      "    // Update all nodes (not leaf).",
      "    for (int64_t i = size - 1; i > 0; i--) {",
      "      update(i);",
      "    }",
      "  }",
      "",
      "  /**",
      "   * @brief Returns the value of the specified leaf.",
      "   *",
      "   * @param k The index of the leaf(0-indexed).",
      "   * @return Value of the specified leaf.",
      "   */",
      "  S get(int64_t k) { return data.at(k + size); }",
      "",
      "  /**",
      "   * @brief Set x into the specified leaf.",
      "   *",
      "   * @param k The index of the leaf(0-indexed).",
      "   * @param x The value.",
      "   */",
      "  void set(int64_t k, S x) {",
      "    // Move to the leaf.",
      "    k += size;",
      "",
      "    // Set the value to the leaf.",
      "    data.at(k) = x;",
      "",
      "    // Update value of the element from the leaf to the root.",
      "    for (int64_t i = 1; i <= log; i++) {",
      "      update(k >> i);",
      "    }",
      "  }",
      "",
      "  /**",
      "   * @brief Returns the result of applying the binary operator to the interval",
      "   * [l, r).",
      "   *",
      "   * @param l Left end of the given interval.",
      "   * @param r Right end of the given interval. it doesn't not include the right",
      "   * end.",
      "   * @return The result.",
      "   */",
      "  S prod(int64_t l, int64_t r) {",
      "    // When invalid interval was given, return the identity element instead.",
      "    if (l >= r) {",
      "      return e();",
      "    }",
      "",
      "    // Move to leaf.",
      "    l += size;",
      "    r += size;",
      "",
      "    // Variable to hold the left side result.",
      "    S left_result = e();",
      "    // Variable to hold the right side result.",
      "    S right_result = e();",
      "",
      "    // Find all nodes covering the given interval.",
      "    while (l < r) {",
      "      // If l is right child:",
      "      if (l & 1) {",
      "        // Calculate result.",
      "        left_result = op(left_result, data.at(l));",
      "        // Move to elder brother.",
      "        l += 1;",
      "      }",
      "",
      "      // If r is right child.",
      "      if (r & 1) {",
      "        // Move to little brother.",
      "        r -= 1;",
      "        // Calculate result.",
      "        right_result = op(right_result, data.at(r));",
      "      }",
      "",
      "      // Move to parent.",
      "      l >>= 1;",
      "      r >>= 1;",
      "    }",
      "",
      "    // Return the result.",
      "    return op(left_result, right_result);",
      "  }",
      "",
      "  /**",
      "   * @brief Returns op(A[0], A[1], ..., A[N - 1]).",
      "   *",
      "   * @return The result.",
      "   */",
      "  S prod_all() { return data.at(1); }",
      "};"
    ],
    "description": "SegmentTree"
  },
  "LazySegmentTree": {
    "prefix": "LazySegmentTree",
    "body": [
      "/**",
      " * @brief Class implementation of non-recursive and abstracted segment tree with",
      " * lazy propagation.",
      " *",
      " * @tparam S Type of the element of segment tree.",
      " * @tparam op(S, S) A function representing the binary operator.",
      " * @tparam e() A function which returns identity element.",
      " * @tparam F Type of the operator.",
      " * @tparam mapping(F, S) A function representing the mapping. This takes the",
      " * operator f and target element s.",
      " * @tparam composition(F, F) A function representing the composition of maps.",
      " * This takes two operator, and returns composited operator.",
      " * @tparam id() A function returns identity mapping.",
      " */",
      "template <class S, S op(S, S), S e(), class F, S mapping(F, S),",
      "          F composition(F, F), F id()>",
      "class LazySegmentTree {",
      " private:",
      "  // Number of the element managed by segment tree.",
      "  int64_t N;",
      "  // The logarithm of size of the segment tree base 2.",
      "  int64_t log;",
      "  // Size of the vector that representing binary tree object.",
      "  int64_t size;",
      "  // A vector of the entities representing segment tree (1-indexed).",
      "  std::vector<S> data;",
      "  // A vector for lazy propagation. lazy[k] holds the operation performed in the",
      "  // segment corresponding to the data[k] which haven't yet been applied to the",
      "  // nodes below the data[k].",
      "  std::vector<F> lazy;",
      "",
      "  /**",
      "   * @brief Calculate smallest power of 2 over n.",
      "   *",
      "   * @param n",
      "   * @return Exponent of the smallest power of 2 over n.",
      "   */",
      "  int64_t get_log(int64_t n) {",
      "    int64_t x = 0;",
      "    while ((1 << x) < n) {",
      "      ++x;",
      "    }",
      "",
      "    return x;",
      "  }",
      "",
      "  /**",
      "   * @brief Reflect the operation on the node.",
      "   *",
      "   * @param k The index of the node(0-indexed).",
      "   * @param f The operator.",
      "   */",
      "  void reflect(int64_t k, F f) {",
      "    // Reflect the operator on the node.",
      "    data.at(k) = mapping(f, data.at(k));",
      "",
      "    // When k is not leaf:",
      "    if (k < size) {",
      "      // Combine the operator f with lazy[k].",
      "      lazy.at(k) = composition(f, lazy.at(k));",
      "    }",
      "  }",
      "",
      "  /**",
      "   * @brief Propagate pending operator lazy[k] to each child, and reset lazy[k].",
      "   *",
      "   * @param k The index of the node(0-indexed).",
      "   */",
      "  void propagate(int64_t k) {",
      "    // Propagate the operator to left child.",
      "    reflect(2 * k, lazy.at(k));",
      "    // Propagate the operator to right child.",
      "    reflect(2 * k + 1, lazy.at(k));",
      "",
      "    // Reset lazy[k].",
      "    lazy.at(k) = id();",
      "  }",
      "",
      "  /**",
      "   * @brief Update value of the element with the value of the child node.",
      "   *",
      "   * @param k The index of the node(0-indexed).",
      "   */",
      "  void update(int64_t k) {",
      "    data.at(k) = op(data.at(2 * k), data.at(2 * k + 1));",
      "  }",
      "",
      " public:",
      "  /**",
      "   * @brief Construct a new Lazy Segment Tree object",
      "   *",
      "   * @param A The vector of the initial value of the leaves.",
      "   */",
      "  explicit LazySegmentTree(std::vector<S> A)",
      "      : N(static_cast<int64_t>(A.size())),",
      "        log(get_log(N)),",
      "        size(1 << log),",
      "        data(2 * size, e()),",
      "        lazy(size, id()) {",
      "    // Initialize the value of leaves with given vector.",
      "    for (int64_t i = 0; i < N; i++) {",
      "      data.at(i + size) = A.at(i);",
      "    }",
      "",
      "    // Update all nodes (not leaf).",
      "    for (int64_t i = size - 1; i > 0; i--) {",
      "      update(i);",
      "    }",
      "  }",
      "",
      "  /**",
      "   * @brief Set x into the specified leaf.",
      "   *",
      "   * @param k The index of the node (0-indexed).",
      "   * @param x The value.",
      "   */",
      "  void set(int64_t k, S x) {",
      "    // Move to leaf.",
      "    k += size;",
      "",
      "    // Propagate pending operator form the root to the leaf.",
      "    for (int64_t i = log; i > 0; i--) {",
      "      propagate(k >> i);",
      "    }",
      "",
      "    // Update value of the element from the leaf to the root.",
      "    for (int64_t i = 1; i <= log; i++) {",
      "      update(k >> i);",
      "    }",
      "  }",
      "",
      "  /**",
      "   * @brief Get the value of the specified leaf.",
      "   *",
      "   * @param k The index of the node (0-indexed).",
      "   * @return S The value.",
      "   */",
      "  S get(int64_t k) {",
      "    // Move to leaf.",
      "    k += size;",
      "",
      "    // Propagate pending operator from the root to the leaf.",
      "    for (int64_t i = log; i > 0; i--) {",
      "      propagate(k >> i);",
      "    }",
      "",
      "    // Return the value.",
      "    return data.at(k);",
      "  }",
      "",
      "  /**",
      "   * @brief Calculate the result of applying the binary operator to the interval",
      "   * [l, r).",
      "   *",
      "   * @param l Left end of the given interval.",
      "   * @param r Right end of the given interval. It doesn't include the right end.",
      "   * @return S The result.",
      "   */",
      "  S prod(int64_t l, int64_t r) {",
      "    // WHen invalid interval was given:",
      "    if (l >= r) {",
      "      return e();",
      "    }",
      "",
      "    // Move to leaf.",
      "    l += size;",
      "    r += size;",
      "",
      "    // Variable to hold the left side result.",
      "    S left_result = e();",
      "    // Variable to hold the right side result.",
      "    S right_result = e();",
      "",
      "    // Propagate pending operator from the root to the leaf.",
      "    // for calculate the production.",
      "    for (int64_t i = log; i > 0; i--) {",
      "      // In the subtree containing the l, when the l is the leftmost node, don't",
      "      // have to propagate. Because the root of the subtree has all information",
      "      // of l.",
      "      if (((l >> i) << i) != l) {",
      "        propagate(l >> i);",
      "      }",
      "",
      "      // Same to above.",
      "      if (((r >> i) << i) != r) {",
      "        propagate((r - 1) >> i);",
      "      }",
      "    }",
      "",
      "    // Find all nodes covering the given interval.",
      "    while (l < r) {",
      "      // If l is right child:",
      "      if (l & 1) {",
      "        // Calculate result.",
      "        left_result = op(left_result, data.at(l));",
      "        // Move to elder brother.",
      "        l += 1;",
      "      }",
      "",
      "      // If r is right child:",
      "      if (r & 1) {",
      "        // Move to little brother",
      "        r -= 1;",
      "        // Calculate result.",
      "        right_result = op(right_result, data.at(r));",
      "      }",
      "",
      "      // Move to each parent.",
      "      l >>= 1;",
      "      r >>= 1;",
      "    }",
      "",
      "    // Return the result.",
      "    return op(left_result, right_result);",
      "  }",
      "",
      "  /**",
      "   * @brief Get the result of applying the binary operator to entire interval.",
      "   *",
      "   * @return The result.",
      "   */",
      "  S prod_all() { return data.at(1); }",
      "",
      "  /**",
      "   * @brief Apply the mapping to the single leaf with specified index.",
      "   *",
      "   * @param k The index of the node (0-indexed).",
      "   * @param f The operator to apply.",
      "   */",
      "  void apply(int64_t k, F f) {",
      "    // Move to leaf.",
      "    k += size;",
      "",
      "    // Propagate pending operator from the root to the leaf.",
      "    for (int64_t i = log; i > 0; i--) {",
      "      propagate(k >> i);",
      "    }",
      "",
      "    // Apply the mapping to the specified leaf.",
      "    data.at(k) = mapping(f, data.at(k));",
      "",
      "    // Update ancestors.",
      "    for (int64_t i = 1; i <= log; i++) {",
      "      update(k >> i);",
      "    }",
      "  }",
      "",
      "  /**",
      "   * @brief Apply the mapping to each leaves of the specified interval [l, r).",
      "   *",
      "   * @param l Left end of the given interval.",
      "   * @param r Right end of the given interval.",
      "   * @param f The operator to be acted on the leabes.",
      "   */",
      "  void apply(int64_t l, int64_t r, F f) {",
      "    // WHen invalid interval was given:",
      "    if (l >= r) {",
      "      return;",
      "    }",
      "",
      "    // Move to leaf.",
      "    l += size;",
      "    r += size;",
      "",
      "    // Propagate pending operator from the root to the leaf.",
      "    // for calculate the production.",
      "    for (int64_t i = log; i > 0; i--) {",
      "      // In the subtree containing the l, when the l is the leftmost node, don't",
      "      // have to propagate. Because the root of the subtree has all information",
      "      // of l.",
      "      if (((l >> i) << i) != l) {",
      "        propagate(l >> i);",
      "      }",
      "",
      "      // Same to above.",
      "      if (((r >> i) << i) != r) {",
      "        propagate((r - 1) >> i);",
      "      }",
      "    }",
      "",
      "    {",
      "      // Copy the variable for temporary calculation.",
      "      int64_t left = l;",
      "      int64_t right = r;",
      "",
      "      // Find all nodes covering the given interval, and apply the mapping to",
      "      // them.",
      "      while (left < right) {",
      "        // If left is right child.",
      "        if (left & 1) {",
      "          // Apply the mapping.",
      "          reflect(left, f);",
      "          // Move to elder brother.",
      "          left += 1;",
      "        }",
      "",
      "        // If right is right child.",
      "        if (right & 1) {",
      "          // Move to little brother.",
      "          right -= 1;",
      "          // Apply the mapping.",
      "          reflect(right, f);",
      "        }",
      "",
      "        // Move to each parent.",
      "        left >>= 1;",
      "        right >>= 1;",
      "      }",
      "    }",
      "",
      "    // Update value of the ancestors.",
      "    for (int64_t i = 1; i <= log; i++) {",
      "      // In the subtree containing the l, when the l is the leftmost node, don't",
      "      // have to propagate. Because the root of the subtree has all information",
      "      // of l.",
      "      if (((l >> i) << i) != l) {",
      "        update(l >> i);",
      "      }",
      "",
      "      // Same to above.",
      "      if (((r >> i) << i) != r) {",
      "        update(r >> i);",
      "      }",
      "    }",
      "  }",
      "};"
    ],
    "description": "LazySegmentTree"
  }
}
